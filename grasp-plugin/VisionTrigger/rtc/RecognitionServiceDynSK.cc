// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "RecognitionService.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_RTC_mTime[] = {
  {"sec", CORBA::TypeCode::PR_ulong_tc()},
  {"nsec", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mTime
#  undef _0RL_tc_RTC_mTime
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTime = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Time:1.0", "Time", _0RL_structmember_RTC_mTime, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_RTC_mTimedDoubleSeq[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_RTC_mTimedDoubleSeq
#  undef _0RL_tc_RTC_mTimedDoubleSeq
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedDoubleSeq = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedDoubleSeq:1.0", "TimedDoubleSeq", _0RL_structmember_RTC_mTimedDoubleSeq, 2, &_0RL_tcTrack);







static CORBA::TypeCode_ptr _0RL_tc_TimedRecognitionResult = CORBA::TypeCode::PR_alias_tc("IDL:TimedRecognitionResult:1.0", "TimedRecognitionResult", _0RL_tc_RTC_mTimedDoubleSeq, &_0RL_tcTrack);


const CORBA::TypeCode_ptr _tc_TimedRecognitionResult = _0RL_tc_TimedRecognitionResult;

const CORBA::TypeCode_ptr _tc_RecognitionService = CORBA::TypeCode::PR_interface_tc("IDL:RecognitionService:1.0", "RecognitionService", &_0RL_tcTrack);

static CORBA::TypeCode_ptr _0RL_tc_RecognitionServiceSDL_mVec3d = CORBA::TypeCode::PR_alias_tc("IDL:RecognitionServiceSDL/Vec3d:1.0", "Vec3d", CORBA::TypeCode::PR_array_tc(3, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr RecognitionServiceSDL::_tc_Vec3d = _0RL_tc_RecognitionServiceSDL_mVec3d;

const CORBA::TypeCode_ptr _tc_RecognitionServiceSDL = CORBA::TypeCode::PR_interface_tc("IDL:RecognitionServiceSDL:1.0", "RecognitionServiceSDL", &_0RL_tcTrack);

static void _0RL_RecognitionService_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RecognitionService_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RecognitionService::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RecognitionService_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RecognitionService_ptr _o)
{
  RecognitionService_ptr _no = RecognitionService::_duplicate(_o);
  _a.PR_insert(_tc_RecognitionService,
               _0RL_RecognitionService_marshal_fn,
               _0RL_RecognitionService_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RecognitionService_ptr* _op)
{
  _a.PR_insert(_tc_RecognitionService,
               _0RL_RecognitionService_marshal_fn,
               _0RL_RecognitionService_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RecognitionService::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RecognitionService_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(_tc_RecognitionService,
                    _0RL_RecognitionService_unmarshal_fn,
                    _0RL_RecognitionService_marshal_fn,
                    _0RL_RecognitionService_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RecognitionService_ptr)_r->_ptrToObjRef(RecognitionService::_PD_repoId);
    else
      _o = RecognitionService::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_RecognitionServiceSDL_mVec3d_marshal_fn(cdrStream& _s, void* _v)
{
  RecognitionServiceSDL::Vec3d_slice* _a = (RecognitionServiceSDL::Vec3d_slice*)_v;
  
#ifndef OMNI_MIXED_ENDIAN_DOUBLE
  if (! _s.marshal_byte_swap()) {
    _s.put_octet_array((_CORBA_Octet*)(_a),24,omni::ALIGN_8);
  }
  else 
#endif
  {
    _s.declareArrayLength(omni::ALIGN_8, 24);
    for (_CORBA_ULong _0i0 = 0; _0i0 < 3; _0i0++){
      _a[_0i0] >>= _s;
    }
  }

}
static void _0RL_RecognitionServiceSDL_mVec3d_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RecognitionServiceSDL::Vec3d_slice* _a = RecognitionServiceSDL::Vec3d_alloc();
  _s.unmarshalArrayDouble((_CORBA_Double*)(_a), 3);

  _v = _a;
}
static void _0RL_RecognitionServiceSDL_mVec3d_destructor_fn(void* _v)
{
  RecognitionServiceSDL::Vec3d_slice* _a = (RecognitionServiceSDL::Vec3d_slice*)_v;
  RecognitionServiceSDL::Vec3d_free(_a);
}

void operator<<=(::CORBA::Any& _a, const RecognitionServiceSDL::Vec3d_forany& _s)
{
  RecognitionServiceSDL::Vec3d_slice* _v;
  if (!_s.NP_nocopy())
    _v = RecognitionServiceSDL::Vec3d_dup(_s);
  else
    _v = _s.NP_getSlice();

  _a.PR_insert(_0RL_tc_RecognitionServiceSDL_mVec3d,
               _0RL_RecognitionServiceSDL_mVec3d_marshal_fn,
               _0RL_RecognitionServiceSDL_mVec3d_destructor_fn,
               _v);
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RecognitionServiceSDL::Vec3d_forany& _s)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RecognitionServiceSDL_mVec3d,
                    _0RL_RecognitionServiceSDL_mVec3d_unmarshal_fn,
                    _0RL_RecognitionServiceSDL_mVec3d_marshal_fn,
                    _0RL_RecognitionServiceSDL_mVec3d_destructor_fn,
                    _v)) {
    _s = (RecognitionServiceSDL::Vec3d_slice*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RecognitionServiceSDL_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_RecognitionServiceSDL_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(RecognitionServiceSDL::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_RecognitionServiceSDL_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, RecognitionServiceSDL_ptr _o)
{
  RecognitionServiceSDL_ptr _no = RecognitionServiceSDL::_duplicate(_o);
  _a.PR_insert(_tc_RecognitionServiceSDL,
               _0RL_RecognitionServiceSDL_marshal_fn,
               _0RL_RecognitionServiceSDL_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, RecognitionServiceSDL_ptr* _op)
{
  _a.PR_insert(_tc_RecognitionServiceSDL,
               _0RL_RecognitionServiceSDL_marshal_fn,
               _0RL_RecognitionServiceSDL_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = RecognitionServiceSDL::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RecognitionServiceSDL_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(_tc_RecognitionServiceSDL,
                    _0RL_RecognitionServiceSDL_unmarshal_fn,
                    _0RL_RecognitionServiceSDL_marshal_fn,
                    _0RL_RecognitionServiceSDL_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (RecognitionServiceSDL_ptr)_r->_ptrToObjRef(RecognitionServiceSDL::_PD_repoId);
    else
      _o = RecognitionServiceSDL::_nil();
    return 1;
  }
  return 0;
}

